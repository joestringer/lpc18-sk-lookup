\documentclass[10pt,sigconf,authorversion]{lpc}
\usepackage{balance}
\usepackage{courier}
\usepackage{helvet}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{times}
\usepackage{xcolor}

\pdfinfo{
/Title (Building socket-aware BPF programs)
/Author (Joe Stringer)}

\title{Building socket-aware BPF programs}
\author{Joe Stringer}
\affiliation{%
      \institution{Cilium.io}}
\email{joe@cilium.io}

\acmDOI{}
\setcounter{secnumdepth}{0}
\setcopyright{none}

\usepackage{xcolor}
\newcommand\todo[1]{\textcolor{red}{#1}}

\begin{document}

\begin{abstract}

    Over the past several years, BPF has steadily become more powerful in
    multiple ways: Through building more intelligence into the verifier which
    allows more complex programs to be loaded, and through extension of the API
    such as by adding new map types and new native BPF function calls. While
    BPF has its roots in applying filters at the socket layer, the ability to
    introspect the sockets relating to traffic being filtered has been limited.

    This paper presents the changes necessary to extend socket introspection
    capabilities of the Linux kernel's BPF packet hooks. To provide safety
    guarantees around the access of the socket, the verifier was extended to
    track allocation and release of kernel resources. Using this mechanism, we
    introduce socket lookup and release helpers into the BPF API.

    %To provide access to socket state from a BPF helper call, the verifier
    %needs the ability to track the safety of the calls, including appropriate
    %reference counting upon the underlying socket for the duration of the
    %access.

    %With such an ability ability in the verifier, we add socket lookup and
    %release function calls to the BPF API, allowing BPF programs to safely find
    %a socket and build logic upon the presence or attributes of a socket.
    %Applications for this functionality range from load-balancing traffic based
    %on the presence of a listening application to building stateful firewalling
    %primitives to understand whether traffic for this connection has been seen
    %before. With this new functionality, BPF programs can integrate more
    %closely with the networking stack's understanding of the traffic transiting
    %the kernel.

    %provide safe access to sockets from BPF packet handling hooks. The BPF verifier
    %is extended to gain understanding of reference-counted pointer types, which
    %allows BPF code paths to 

\end{abstract}

\maketitle

\section{Keywords}

BPF, Linux, packet processing, sockets

\section{Introduction}

% Over the past several years, BPF has steadily become more powerful in
% multiple ways: Through building more intelligence into the verifier which
% allows more complex programs to be loaded, and through extension of the API
% such as by adding new map types and new native BPF function calls. While
% BPF has its roots in applying filters at the socket layer, the ability to
% introspect the sockets relating to traffic being filtered has been limited.

To build such awareness into a BPF helper, the verifier needs the ability to
track the safety of the calls, including appropriate reference counting upon
the underlying socket. This talk walks through extensions to the verifier to
perform tracking of references in a BPF program. This allows BPF developers to
extend the UAPI with functions that allocate and release resources within the
execution lifetime of a BPF program, and the verifier will validate that the
resources are released exactly once prior to program completion.

Using this new reference tracking ability in the verifier, we add socket lookup
and release function calls to the BPF API, allowing BPF programs to safely find
a socket and build logic upon the presence or attributes of a socket. This can
be used to load-balance traffic based on the presence of a listening
application, or to implement stateful firewalling primitives to understand
whether traffic for this connection has been seen before. With this new
functionality, BPF programs can integrate more closely with the networking
stack's understanding of the traffic transiting the kernel.

This safety is provided by tracking pointer values through each conditional
path in the program, and rejecting the load of programs that fail to "balance"
resource acquisition (lookup) with release.

\section{Background}

The BPF verifier must ensure that all BPF programs that are loaded into the
kernel are safe to execute. For proposed access into socket types, this
requires validation that memory accesses within the socket memory are
appropriate with respect to the bounds of the structure and the norms of
read/write access, as well as guaranteeing that underlying socket memory
remains associated with the socket for the duration of accesses from the BPF
program.

For some socket types, such as UDP sockets, or TCP listen sockets, memory
access safety can be achieved with minimal implementation: The destruction of
such sockets is already governed by standard RCU rules, meaning that while the
RCU lock is held, they can be safely referenced; Once the RCU grace period is
reached, the memory may be freed and references to the socket are no longer
safe to use. Because BPF programs run under the RCU lock, this allows simple,
safe access of properties of these sockets without requiring additional
mechanisms to ensure the safety of the socket pointers.

When it comes to TCP sockets that are not governed by RCU, the networking stack
uses reference counting to manage socket memory instead. To ensure that the
socket remains safe to access for a period of BPF program execution, the BPF
program must also take a reference on the socket. This also implies that such
references must be subsequently released to prevent leaking kernel resources.

\subsection{Pointers to Sockets}

Earlier work~\cite{bpf-sock} introduced a \verb+bpf_sock+ structure to the BPF
API and implemented bounds and access type checking, along with offset
rewriting for converting the access of socket attributes from BPF instructions
into equivalent accesses of the underlying kernel types. This work was
introduced with new BPF hook points which provide the socket structure as the
context of the BPF program.

To allow BPF programs to retrieve and access a socket pointer, the verifier
must be made aware of when a register contains a pointer of this type, and also
how to validate pointer access. The existing verifier logic handles context
pointers in a generic manner via \verb+bpf_verifier_ops+. However, the packet
event hook points targeted in this paper already contain a context pointer of a
type that is different from \verb+bpf_sock+, so some additional logic was
required in the verifier to understand this pointer type. The patch series
associated with this paper introduced a new pointer type specific to sockets,
and linked its validation directly to the aforementioned socket verification
functions without using the verifier operations abstraction.

With the verifier now aware of socket pointer types, this could be built upon
to implicitly associate socket pointers with references to kernel resources.

\subsection{Reference tracking}

Alternatives:
\begin{itemize}
\item RCU-protect other socket types
\item Collect references during program execution and release afterwards
\item Build acquire/release semantics into the API
\end{itemize}

Collecting references and releasing afterwards has the unfortunate overhead
that even the execution of BPF programs that do not make use of the new socket
lookup helpers would need to pay the cost of checking the list of references
to free. When dealing with sufficiently demanding use cases such as those which
use XDP, even the few instructions required to implement such a check may have
a measurable impact on performance.

Calls to helper functions which acquire references to resources are annotated
in the verifier to associate the acquisition and release functions. When the
instruction that acquires a resource is processed, the verifier state is
updated to include a resource identifier for the resulting value, and the
register's value is associated with this identifier. When processing a
corresponding release helper call, if a parameter to the function contains a
resource identifier, then the corresponding identifire is removed from the
verifier state. If any paths in the program reach the final (\verb+BPF_EXIT+)
instruction and the verifier state still contains resource identifiers, then
the program is considered unsafe as it has leaked the resource.

\subsection{Runtime protection}

\todo{LD\_ABS, LD\_IND}

\section{Extending the BPF API}



\section{Use cases}

\subsection{Stateful Firewalling}

\subsection{Load-balancing}

\section{Conclusion}

This paper describes the contribution of two extensions to the Linux kernel BPF
implementation, firstly the introduction of reference tracking logic into the
verifier, which provides useful base infrastructure for supporting acquire and
release semantics for kernel resources, and secondly the socket lookup API
which may be now used from packet paths to allow BPF writers to build logic
based upon introspection of kernel sockets.

\section{Acknowledgments}

The core BPF maintainers for their guidance and review of the patches.

\bibliographystyle{plainnat}
\bibliography{paper}

\end{document}
